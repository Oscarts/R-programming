---
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
intall.package("rmarkdown")
install.package("rmarkdown")
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
<http://rmarkdown.rstudio.com>.
sudo tlmgr update --self
---
---
hello why it doesn´t work?
opts_chunk$set(dev = 'pdf')
date: "July 23, 2014"
date: "July 23 2014"
date: "July,23 of 2014"
date: "07/23/2014"
date: "July 23, 2014"
date: July 23, 2014
date: July 23 2014
date: 07/23/2014
date: "07/23/2014"
email: "oskarts@gmail.com"
e-mail: "oskarts@gmail.com"
author: "Oscar Tellez"
author: Oscar Tellez
author: "Oscar Tellez"
author: "Oscar Tellez"
author: Oscar Tellez
author: "Oscar Tellez"
date: "july 23, 2014"
hello why it doesn´t work for pdf?
hello why it doesn´t work for pdf?
## R language
40 years old technology.
few support in dynamic and 3d graphics
x<-2
x<-2:10
x
x <- 1:20  # Integer vector from 1 to 20
y <- c(0.5, 0.6) #c comes from concatenate
z <- c(“a”, “b”, “c”)
x <- 1:20  # Integer vector from 1 to 20
y <- c (0.5, 0.6) #c comes from concatenate
z <- c (“a”, “b”, “c”)
x <- 1:20  # Integer vector from 1 to 20
y <- c (0.5, 0.6) #c comes from concatenate
z <- c (“a”, “b”)
x <- 1:20  # Integer vector from 1 to 20
y <- c (0.5, 0.6) #c comes from concatenate
z <- c (“a”, “b”)
x <- 1:20  # Integer vector from 1 to 20
y <- c (0.5, 0.6) #c comes from concatenate
x <- 1:20  # Integer vector from 1 to 20
y <- c (0.5, 0.6) #c comes from concatenate
z <- c ('a', 'b')  # char vector
c(“a” , 1.7)
z<-matrix(1:6 ,nrow=2,ncol=3)
z
x<-list('a',1,1+i,true)
x<-list('a',1,1+1i,true)
x<-list('a',1, 1 + i ,TRUE)
x<-list('a',1 , 1 + i ,TRUE)
x <-list('a',1 , 1 + 4i ,TRUE)
x <-list('a',1 , 1 + 1i ,TRUE)
x <-list('a',1 , 1 + i ,TRUE)
x<-factor(c('yes','yes', 'no', 'yes', 'no'))
x
table(x)
unclass(x)
attr(,'levels')
x<-factor(c('yes','yes', 'no', 'yes', 'no'))
x
table(x) ## tabular form
unclass(x) ## attributes
x<-data.frame(col1=1:4,col2=c(T,F,F,T))
x<-data.frame(col1=1:4,col2=c(T,F,F,T))
X
x<-data.frame(col1=1:4,col2=c(T,F,F,T))
x
z<-matrix(1:6 ,nrow=2,ncol=3)
dimnames<-list(c('r1','r2'),c('c1','c2','c3')) #optionally you can add names to rows and columns, by default are na.
z
z<-matrix(1:6 ,nrow=2,ncol=3)
#optionally you can add names to rows and columns, by default are na.
dimnames<-list(c('r1','r2'),c('c1','c2','c3'))
z
z<-matrix(1:6 ,nrow=2,ncol=3)
#optionally you can add names to rows and columns, by default are na.
#dimnames<-list(c('r1','r2'),c('c1','c2','c3'))
z
z<-matrix(1:6 ,nrow=2,ncol=3)
#optionally you can add names to rows and columns, by default are na.
dimnames(z)<-list(c('r1','r2'),c('c1','c2','c3'))
z
x <- 1:4  # Integer vector from 1 to 24
names(x)<-c('e1','e2','e3')
y <- c (0.5, 0.6) #c comes from concatenate
z <- c ('a', 'b')  # char vector
y <- c (0.5, 0.6) #c comes from concatenate
z <- c ('a', 'b')  # char vector
x <- 1:4  # Integer vector from 1 to 24
names(x)<-c('e1','e2','e3')  # names are optional
y <- c (0.5, 0.6) #c comes from concatenate
z <- c ('a', 'b')  # char vector
x <- 1:4  # Integer vector from 1 to 24
names(x)<-c('e1','e2','e3')  # names are optional
x
x<-factor(c('yes','yes', 'no', 'yes', 'no'), levels=c('yes','no'))
## levels arg is optional whe you want to set an order different than alphabetica.
## first arg is baseline level.
x
table(x) ## tabular form
unclass(x) ## attributes
x<-matrix(1:6,2,3)
x[2,3]
x[[2]][[3]]
x<-matrix(1:6,2,3)
x[2,3]
#x[[2]][[3]]
x<-matrix(1:6,2,3)
x[2,3]
x[2][3]
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
x[2,3] # for an specific elements
x[2][3] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
x[2,3] # for an specific elements
y[2][3] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
y[2,3] # for an specific elements
y[2][3] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
x[2,3] # for an specific elements
y[[2]][[3]] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call col 1 of a matrix
y[[1]] # col1 of a list
x[2,3] # for an specific elements
y[[2]][[3]] # for an element of a list
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
y[[1]] # col1 of a list
x[2,3] # for an specific elements
y[[2]][[3]] # for an element of a list
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1], drop=FALSE] # col1 of a list
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
y<-list(listado=c('a','b','c'),m=c(1,2,3))
y[[$l]]
y<-list(listado=c('a','b','c'),m=c(1,2,3))
y$l
x<-data.frame( par1=(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f')
x<-data.frame( par1=c(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f')
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f')
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f'))
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
xGood<-complete.cases(x)
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
xGood<-complete.cases(x)
xGood
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[[good]]
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[!good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[!good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
x[!good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
good<-complete.cases(x)
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
#good<-complete.cases(x[[1]],x[[2]])
good<-complete.cases(x)
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[[!good]]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[1]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[[1]]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good,]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[]][[1]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[c(,1)]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[1]][[]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[1]][[c(1,2)]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[c(1,)]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[1, ] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
y<-data.frame(listado=c('a','b','c'),m=c(1,2,3))
y$lis  #find the first coincidence
x<-data.frame(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good]
x<-data.frame(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good,]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[1, ] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
library(datasets)
data(iris)
head$iris
head(iris)
mean(iris$Sepal.Lenghth)
mean(iris$Sepal.Lenghth,rm.na=T)
mean(iris$Sepal.Lenghth, rm.na=T)
mean?
?
;
??mean
mean(iris$Sepal.Lenghth, na.rm=T)
mean(iris$Sepal.Lenghth, na.rm=TRUE)
mean(iris$Sepal.Lenghth, rm.na=TRUE)
mean(iris$Sepal.Lenghth, na.rm=T)
mean(iris$Sepal.Lenghth, na.rm=F)
mean(iris$Sepal.Length, na.rm=T)
round(mean(iris$Sepal.Length, na.rm=T),4)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
tapply(mtcars$mpg, mtcars$cyl, mean)
x<-tapply(mtcars$mpg, mtcars$cyl, mean)
round(x[1]-x[3],4)
head(mtcars)
x<-tapply(mtcars$hp, mtcars$cyl, mean)
x[1]-x[3]
x[1]-x[3]
mean(iris$Sepal.Length, na.rm=T)
str(ls)
str(ls)
f<-gl(40,10)
f<-gl(5,10)
f
str(f)
summary(f)
library(airquality)
library(datasets)
summary(airquality)
str(airquality)
set.seed(20)
x<-rnorm(100)
e<-rnorm(100,0,2)
y<-2 *x + 0.5 + e
plot(x,y)
set.seed(20)
x<-rbin(100,1,0.4)
e<-rnorm(100,0,2)
y<-2 *x + 0.5 + e
plot(x,y)
set.seed(20)
x<-rbinom(100,1,0.4)
e<-rnorm(100,0,2)
y<-2 *x + 0.5 + e
plot(x,y)
set.seed(1)
x<-rnorm(100)
log.mu<-0.5+0.3*x
y<-rpois(100,exp(log.mu))
plot(x,y)
str(airquality)
fixed=c[FALSE,FALSE]
fixed=c(FALSE,FALSE)
fixed
params<-fixed
params
params[!fixed]
params[fixed]
params[TRUE]
params[FALSE]
make.NegLogLik <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed  # Defines parameters
function( p ) {  # calling make.NegLogLik will return this fuction.
params[!fixed] <- p # assigns parameters
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data-mu)^2) / (sigma^2)
-(a + b) # this is the objective function that would be maximized (-)
}
}
# 2. Add data
set.seed(1)
normals <- rnorm(100, 1, 2)
# 3. create function
nLL <- make.NegLogLik(normals)
nLL
# data in the function inside is a free variable, and the data can be look at the environment where it was defined, it is in the make.negLogLik function.
# 4. optimize
optim(c(mu = 0, sigma = 1), nLL)$par # here we use optimim because there are 2 vars the parameters are the parameters of nLL and nLL!
#Fixing sigma = 2, here i don´t have to redefine data because it is enclosed with the environment of the objective fuction.
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum  # optmize for one variable
make.NegLogLik <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed  # Defines parameters
function( p ) {  # calling make.NegLogLik will return this fuction.
params[!fixed] <- p # assigns parameters
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data-mu)^2) / (sigma^2)
-(a + b) # this is the objective function that would be maximized (-)
}
}
# 2. Add data
set.seed(1)
normals <- rnorm(100, 1, 2)
# 3. create function
nLL <- make.NegLogLik(normals)
nLL
# data in the function inside is a free variable, and the data can be look at the environment where it was defined, it is in the make.negLogLik function.
# 4. optimize
optim(c(mu = 0, sigma = 1), nLL)$par # here we use optimim because there are 2 vars the parameters are the parameters of nLL and nLL!
#Fixing sigma = 2, here i don´t have to redefine data because it is enclosed with the environment of the objective fuction.
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum  # optmize for one variable
# Plotting
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "1")
make.NegLogLik <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed  # Defines parameters
function( p ) {  # calling make.NegLogLik will return this fuction.
params[!fixed] <- p # assigns parameters
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data-mu)^2) / (sigma^2)
-(a + b) # this is the objective function that would be maximized (-)
}
}
# 2. Add data
set.seed(1)
normals <- rnorm(100, 1, 2)
# 3. create function
nLL <- make.NegLogLik(normals)
nLL
# data in the function inside is a free variable, and the data can be look at the environment where it was defined, it is in the make.negLogLik function.
# 4. optimize
optim(c(mu = 0, sigma = 1), nLL)$par # here we use optimim because there are 2 vars the parameters are the parameters of nLL and nLL!
#Fixing sigma = 2, here i don´t have to redefine data because it is enclosed with the environment of the objective fuction.
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum  # optmize for one variable
# Plotting
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
rpois(5, 2)
set.seed(1)
rpois(5, 2)
install.packages("swirl")
library("swirl")swirl()
library("swirl")
swirl()
1
head(flags)
dim(flags)
class(flags)
lista<-lapply(flags,class)
cls_list<-lapply(flags,class)
cls_list
class(cls_list)
as.character(cls_list)
sapply(flags,class)
cls_vect<-sapply(flags,class)
class(cls_vect)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
setwd("~/Documents/R-programming/ProgAssignment3")
submit()
submit()
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
submit()
submit()
tail(rankall("heart failure"), 10)
source("rankall.r")
tail(rankall("heart failure"), 10)

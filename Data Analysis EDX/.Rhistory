z<-matrix(1:6 ,nrow=2,ncol=3)
#optionally you can add names to rows and columns, by default are na.
#dimnames<-list(c('r1','r2'),c('c1','c2','c3'))
z
z<-matrix(1:6 ,nrow=2,ncol=3)
#optionally you can add names to rows and columns, by default are na.
dimnames(z)<-list(c('r1','r2'),c('c1','c2','c3'))
z
x <- 1:4  # Integer vector from 1 to 24
names(x)<-c('e1','e2','e3')
y <- c (0.5, 0.6) #c comes from concatenate
z <- c ('a', 'b')  # char vector
y <- c (0.5, 0.6) #c comes from concatenate
z <- c ('a', 'b')  # char vector
x <- 1:4  # Integer vector from 1 to 24
names(x)<-c('e1','e2','e3')  # names are optional
y <- c (0.5, 0.6) #c comes from concatenate
z <- c ('a', 'b')  # char vector
x <- 1:4  # Integer vector from 1 to 24
names(x)<-c('e1','e2','e3')  # names are optional
x
x<-factor(c('yes','yes', 'no', 'yes', 'no'), levels=c('yes','no'))
## levels arg is optional whe you want to set an order different than alphabetica.
## first arg is baseline level.
x
table(x) ## tabular form
unclass(x) ## attributes
x<-matrix(1:6,2,3)
x[2,3]
x[[2]][[3]]
x<-matrix(1:6,2,3)
x[2,3]
#x[[2]][[3]]
x<-matrix(1:6,2,3)
x[2,3]
x[2][3]
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
x[2,3] # for an specific elements
x[2][3] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
x[2,3] # for an specific elements
y[2][3] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
y[2,3] # for an specific elements
y[2][3] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call row 1
x[2,3] # for an specific elements
y[[2]][[3]] #
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[1,] # to call col 1 of a matrix
y[[1]] # col1 of a list
x[2,3] # for an specific elements
y[[2]][[3]] # for an element of a list
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
y[[1]] # col1 of a list
x[2,3] # for an specific elements
y[[2]][[3]] # for an element of a list
#x[[2]][[3]]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1], drop=FALSE] # col1 of a list
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
y<-list(listado=c('a','b','c'),m=c(1,2,3))
y[[$l]]
y<-list(listado=c('a','b','c'),m=c(1,2,3))
y$l
x<-data.frame( par1=(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f')
x<-data.frame( par1=c(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f')
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f')
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=('m','f',NA,'m','f',NA,'f'))
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
xGood<-complete.cases(x)
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
xGood<-complete.cases(x)
xGood
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[[good]]
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par1=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[!good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x)
x[!good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
x[!good]
x<-list(par1=c(1,1,NA,3,4,NA,2),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x[[1]],x[[2]])
good<-complete.cases(x)
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
#good<-complete.cases(x[[1]],x[[2]])
good<-complete.cases(x)
good
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[!good]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[[!good]]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[1]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[[1]]
x<-list(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good,]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[]][[1]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[c(,1)]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[1]][[]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[1]][[c(1,2)]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[[c(1,)]] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[1, ] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
y<-data.frame(listado=c('a','b','c'),m=c(1,2,3))
y$lis  #find the first coincidence
x<-data.frame(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good]
x<-data.frame(par1=c(1,1,NA,3,4,1,NA),par2=c('m','f',NA,'m','f',NA,'f'))
good<-complete.cases(x) # which equals to good<-complete.cases(x[[1]],x[[2]])
x[good,]
x<-matrix(1:6,2,3)
y<-list(col1=1:6, col2=c('a','b','c'))
x[,1] # to call col 1 of a matrix
x[,1, drop=FALSE] # To maintain the matrix format
y[[1]] # col1 of a list
y[1, ] # first row
x[2,3] # for an element of a matrix
y[[2]][[3]] # for an element of a list
library(datasets)
data(iris)
head$iris
head(iris)
mean(iris$Sepal.Lenghth)
mean(iris$Sepal.Lenghth,rm.na=T)
mean(iris$Sepal.Lenghth, rm.na=T)
mean?
?
;
??mean
mean(iris$Sepal.Lenghth, na.rm=T)
mean(iris$Sepal.Lenghth, na.rm=TRUE)
mean(iris$Sepal.Lenghth, rm.na=TRUE)
mean(iris$Sepal.Lenghth, na.rm=T)
mean(iris$Sepal.Lenghth, na.rm=F)
mean(iris$Sepal.Length, na.rm=T)
round(mean(iris$Sepal.Length, na.rm=T),4)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
tapply(mtcars$mpg, mtcars$cyl, mean)
x<-tapply(mtcars$mpg, mtcars$cyl, mean)
round(x[1]-x[3],4)
head(mtcars)
x<-tapply(mtcars$hp, mtcars$cyl, mean)
x[1]-x[3]
x[1]-x[3]
mean(iris$Sepal.Length, na.rm=T)
str(ls)
str(ls)
f<-gl(40,10)
f<-gl(5,10)
f
str(f)
summary(f)
library(airquality)
library(datasets)
summary(airquality)
str(airquality)
set.seed(20)
x<-rnorm(100)
e<-rnorm(100,0,2)
y<-2 *x + 0.5 + e
plot(x,y)
set.seed(20)
x<-rbin(100,1,0.4)
e<-rnorm(100,0,2)
y<-2 *x + 0.5 + e
plot(x,y)
set.seed(20)
x<-rbinom(100,1,0.4)
e<-rnorm(100,0,2)
y<-2 *x + 0.5 + e
plot(x,y)
set.seed(1)
x<-rnorm(100)
log.mu<-0.5+0.3*x
y<-rpois(100,exp(log.mu))
plot(x,y)
str(airquality)
fixed=c[FALSE,FALSE]
fixed=c(FALSE,FALSE)
fixed
params<-fixed
params
params[!fixed]
params[fixed]
params[TRUE]
params[FALSE]
make.NegLogLik <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed  # Defines parameters
function( p ) {  # calling make.NegLogLik will return this fuction.
params[!fixed] <- p # assigns parameters
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data-mu)^2) / (sigma^2)
-(a + b) # this is the objective function that would be maximized (-)
}
}
# 2. Add data
set.seed(1)
normals <- rnorm(100, 1, 2)
# 3. create function
nLL <- make.NegLogLik(normals)
nLL
# data in the function inside is a free variable, and the data can be look at the environment where it was defined, it is in the make.negLogLik function.
# 4. optimize
optim(c(mu = 0, sigma = 1), nLL)$par # here we use optimim because there are 2 vars the parameters are the parameters of nLL and nLL!
#Fixing sigma = 2, here i don´t have to redefine data because it is enclosed with the environment of the objective fuction.
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum  # optmize for one variable
make.NegLogLik <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed  # Defines parameters
function( p ) {  # calling make.NegLogLik will return this fuction.
params[!fixed] <- p # assigns parameters
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data-mu)^2) / (sigma^2)
-(a + b) # this is the objective function that would be maximized (-)
}
}
# 2. Add data
set.seed(1)
normals <- rnorm(100, 1, 2)
# 3. create function
nLL <- make.NegLogLik(normals)
nLL
# data in the function inside is a free variable, and the data can be look at the environment where it was defined, it is in the make.negLogLik function.
# 4. optimize
optim(c(mu = 0, sigma = 1), nLL)$par # here we use optimim because there are 2 vars the parameters are the parameters of nLL and nLL!
#Fixing sigma = 2, here i don´t have to redefine data because it is enclosed with the environment of the objective fuction.
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum  # optmize for one variable
# Plotting
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "1")
make.NegLogLik <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed  # Defines parameters
function( p ) {  # calling make.NegLogLik will return this fuction.
params[!fixed] <- p # assigns parameters
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data-mu)^2) / (sigma^2)
-(a + b) # this is the objective function that would be maximized (-)
}
}
# 2. Add data
set.seed(1)
normals <- rnorm(100, 1, 2)
# 3. create function
nLL <- make.NegLogLik(normals)
nLL
# data in the function inside is a free variable, and the data can be look at the environment where it was defined, it is in the make.negLogLik function.
# 4. optimize
optim(c(mu = 0, sigma = 1), nLL)$par # here we use optimim because there are 2 vars the parameters are the parameters of nLL and nLL!
#Fixing sigma = 2, here i don´t have to redefine data because it is enclosed with the environment of the objective fuction.
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum  # optmize for one variable
# Plotting
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
rpois(5, 2)
set.seed(1)
rpois(5, 2)
install.packages("swirl")
library("swirl")swirl()
library("swirl")
swirl()
1
head(flags)
dim(flags)
class(flags)
lista<-lapply(flags,class)
cls_list<-lapply(flags,class)
cls_list
class(cls_list)
as.character(cls_list)
sapply(flags,class)
cls_vect<-sapply(flags,class)
class(cls_vect)
z<-matrix(1:6 ,nrow=2,ncol=3)
fix(z)
#optionally you can add names to rows and columns, by default are na.
dimnames(z)<-list(c('r1','r2'),c('c1','c2','c3'))
z
z<-matrix(1:6 ,nrow=2,ncol=3)
fix(z)  # kind of spreadsheet
#optionally you can add names to rows and columns, by default are na.
dimnames(z)<-list(c('r1','r2'),c('c1','c2','c3'))
z
x <-list('a',1 , 1 + 1i ,TRUE,matrix(1:6,2,4))
x <-list('a',1 , 1 + 1i ,TRUE,matrix(1:6,2,3))
x <-list('a',1 , 1 + 1i ,TRUE,matrix(1:6,2,3))
x
x <-list('a',1 , 1 + 1i ,TRUE,matrix(1:6,2,3))
x
x[[5]][,2]
swirl()
library("swirl")
swirl()
swirl()
?sample
sample(1:6,4,replace=TRUE)
sample(1:6,4,replace=TRUE)
sample(1:6,4,replace=F)
sample(1:20,10,replace=F)
sample(1:20,10)
LETTER?
LETTERS?
;
LETTERS
sample(LETTERS)
sample(c(o,1),100, replace=TRUE,c(0.3,0.7))
sample(c(0,1),100, replace=TRUE,c(0.3,0.7))
flips<-sample(c(0,1),100, replace=TRUE,c(0.3,0.7))
sample(1:10, replace=TRUE)
flips<-sample(c(0,1),100, replace=TRUE,c(0.3,0.7)) # unfair coin 0 prob 0.3 1 with prob 0.7
flips
sum(flips)
rbinom()?
;
?rbinm()
?rbinom()
?rbinom
rbin(1,100,0.7)
rbinom(1,100,0.7)
flips2<-rbinom(1,100,0.7)
flips2<-rbinom(100,1,0.7)
flips2
sum(flips2)
?rnorm
rnorm(10)
rnorm(10, mean=100,sd=25)
?rpois
rpois(5,10)
mypois<-replicate(100,rpois(5,10))
my_pois<-replicate(100,rpois(5,10))
my_pois
cm<-colMeans(my_pois)
hist(cm)
f<-c(1,2,3)
2.3<-f[3]
sample?
;
?sample
str(sample(letters[1:4],100,replace=F))
str(replicate(100,sample(letters[1:4],4,replace=F)))
?table
sample(letters[1:4],100,replace=T)
a<-sample(letters[1:4],100,replace=T)
table(a)
pie(a)
pie(table(a))
a<-sample(letters[1:4],100,replace=T)
ta<-table(a)
pie(ta)
length <- rnorm(10, 180, 10)
length
setwd("/Users/oscar/Documents/R-programming/Data Analysis")
setwd('/Users/oscar/Documents/R-programming/Data Analysis')
setwd("~/Documents/R-programming/Data Analysis EDX")
a<-read.csv('List_P_3D_data.csv')
head(a)
str(A)
str(a)
a<-read.table('List_P_3D_data.csv')
a<-read.table('List_P_3D_data.csv',header=T,sep='\t')
str(A)
str(a)
a<-read.table('List_P_3D_data.csv',header=T,sep=';')
str(a)
b<-read.table(pipe('pbpaste'),header=T,sep='\t')
str(b)
head(a)
names(a)
measurements<-c('EDV','ESV','SV','EF')
paste(measurements,'3D','.')
measurements
paste(measurements,'3D',sep='.')
(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep='.'))
c(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep='.'))
names('subject',c(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep='.')))
names('subject',c(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep=z'.'))x)
names<-c('subject',c(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep='.')))
names
names(a)<-c('subject',c(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep='.')))
str(a)
setwd("~/Documents/R-programming/Data Analysis EDX")
b<-read.table('List_P_3D_data.csv',header=T,sep=';')
measurements<-c('EDV','ESV','SV','EF')
names(a)<-c('subject',c(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep='.'))) # fixed names
setwd("~/Documents/R-programming/Data Analysis EDX")
b<-read.table('List_P_3D_data.csv',header=T,sep=';')
measurements<-c('EDV','ESV','SV','EF')
names(b)<-c('subject',c(paste(measurements,'3D',sep='.'),paste(measurements,'2D',sep='.'))) # fixed names
str(b)
str(b)
b<-b[,-10:12]
b<-b[,-10:-12]
str(b)
head(b)
tail(b)
b<-b[-31:-33,-10:-12] # it deletes last 3 columns and rows (- is to remove!)
tail(b)
str(b)
?scan
